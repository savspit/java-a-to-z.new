В связи с тем, что основной упор в данной задаче идет на скорость выполнения, именно от этого я и отталкивался.

1. Парсинг файла.

Первое, что пришло в голову - парсинг xml-файла можно осуществить соответствующими парсерами.
Из существующих парсеров у нас есть:
- SAX (парсинг "на лету", не загружает в память весь XML, подходит "более чем"),
- StAX (чуть лучше SAX, но лишь в некоторых случаях),
- DOM (сначала загружает весь документ в java-объект, а потом можно работать).
SAX - прочитал файл приблизительно за 6 сек.
StAX - по результатам SAX пробовать не стал.
DOM - не рассматривался из-за низкой скорости.
В итоге получилось, что SAX нам более-менее подходит.
Тогда я создал простую коллекцию TreeSet и попробовал добавить туда только Book. Результат - 7 сек., а Book - всего 3 штуки.
Оказалось, что стандартные парсеры не подходят вовсе.

Из способов чтения файлов в принципе существует еще BufferedReader. Это, конечно, не xml-парсер, но и xml-файл по факту текстовый файл со своей структурой (собственно, как ini-файлы и т.д).
Вот тут результат удивил. Построчное чтение файла - 2,5 сек.

В поиске еще быстрого чтения файла я наткнулся на RandomAccessFile и NIO. Как я понял, это все стандартные механизмы java, поэтому решение было в пределах задачи. Результат чтения файла был впечатляющим - 77 ms!!!
Но, к сожалению, он читает файлы побайтово и на последующий разбор данных уходит гораздо больше времени, что, в итоге, вылилось в ~ 6 сек., что, конечно же не подошло.

В итоге я решил использовать BufferedReader, т.к. ограничений по парсерам в задаче нет.
Но, хотелось бы сказать, что это хорошо лишь для тех случаев, когда формат xml-файла известен. В случаях, когда он может поменяться (даже незначительно) - файл не загрузится, а это не очень хорошо.

2. Разбор считываемых строк файла

BufferedReader читает файл построчно. Значит необходимо эти строки как-то разобрать.
Регулярки работали очень долго. Просто не дождался.
Все попытки использовать indexOf, substring привели к хорошим, но не очень подходящим результатам.
Использование split показало хороший результат, т.к. при regex (то, что ищем в строке и по чему она будет разбиваться) в один символ split не использует регулярки, а использует более адекватный подход. По хорошему у нас regex и есть один символ, символ кавычки '\"', а значит split нам подходит.
Но, в общем случае, было необходимо как-то улучшить этот механизм, чтобы получить еще больший выигрыш в скорости.

В итоге, посмотрев на общий принцип работы java-методов split и substring я написал свой метод splitStr (в классе ReadXMLFile), что дало выигрыш в 500 ms на весь файл.

3. Загрузка данных из файла в коллекцию.

Из коллекций была выбрана только одна - TreeMap.
Данная коллекция является сбалансированным красно-черным деревом и даже в худшем случае на все операции (вставка, удаление и т.д.) показывает лучшее время - O(log(n)), что нам и необходимо (не забываем, что на всё нам дано около 6 сек).
Т.к. выводить итоговые данные нам придется в определенном формате, в котором сперва будут отсортированы Book по наименованию,
а потом Orders, - учтем это и сделаем такую коллекцию:
- TreeMap<String, Book> ts = new TreeMap<>(new BookCompAsc()), где BookCompAsc как раз и упорядочит Book по наименованию.
В свою очередь, в каждой Book сделаем такие коллекции:
- TreeMap<KeySort,Order> sellOrders - заявки с признаком SELL. Именно здесь будут происходить основные манипуляции с заявками SELL
- TreeMap<KeySort,Order> buyOrders - заявки с признаком BUY. Именно здесь будут происходить основные манипуляции с заявками BUY
- TreeMap<KeySort,Order> sellOrdersSort - сюда мы загрузим sellOrders, а затем выведем их на экран
- TreeMap<KeySort,Order> buyOrdersSort - сюда мы загрузим buyOrders, а затем выведем их на экран

Итак, имеем четыре коллекции, из которых:
a) sellOrders - отсортированная по ключу KeySort коллекция, в которую будут попадать заявки с признаком SELL и обрабатываться соответствующим образом
b) buyOrders - отсортированная по ключу KeySort коллекция, в которую будут попадать заявки с признаком BUY и обрабатываться соответствующим образом

Ключ KeySort представляет из себя класс, содержащий поля:
- orderId и price.
Объясню почему так. Заявки в xml-файле упорядочены по orderId, а значит мы это можем использовать.
В задаче сказано, что нужно искать соответствие между заявками bid/ask по признаку bid>=ask. Вот именно это мы и используем для ускорения всего процесса.
- sellOrders отсортируем сперва по orderId (asc), а потом по price (asc)
- buyOrders отсортируем сперва по orderId (asc), а потом по price (desc)
Данные сортировки позволят нам быстрее попасть на необходимые данные, их обработать, а после обработки выйти (чтобы не обрабатывать каждый раз коллекцию полностью).

c) sellOrdersSort - отсортированная по ключу KeySort коллекция, но тут сортировка ключа будет только по price (asc)
d) buyOrdersSort - отсортированная по ключу KeySort коллекция, но тут сортировка ключа будет только по price (desc)
Эти коллекции являются итоговыми и нужны только для вывода результата.
В них мы загрузим уже итоговые, обработанные данные из соответствующих коллекций sellOrders и buyOrders.

4. Удаление данных из коллекций.

В результате обработки коллекций, и в результате загрузки данных из файла существуют моменты, когда заявки из коллекций нам необходимо удалить.
И удаление это должно быть довольно быстрым.
Для этих случаев мы будем обходить коллекцию итератором и для удаления использовать remove. По результатам тестов это удаление происходит корректно.

5. Обход коллекций и их вывод на экран.

Эти две операции будем производить итератором, т.к. в общем случае он показывает чуть лучшее время, чем foreach.

6. Вывод на экран

Эту операцию будем производить с помощью StringBuffer, т.к
- у нас определенный формат вывода, данный в задаче
- обычная конкатенация строк работает гораздо дольше StringBuffer

7. Тесты

В связи с тем, что основная суть - скорость выполнения поставленной задачи - тест будет только один.
Он 10 раз загрузит один и тот же файл и выведет результат.

8. Итог

Общий результат выполнения теста чуть меньше 6000 ms, что соответствует поставленной задаче.

Ответы на некоторые вопросы:

- почему существует класс OperationEnum ?
Т.к. он используется в нескольких местах и его существование ускорило процесс обработки - enum был создан именно как класс.
По результатам тестов operationValue == OperationEnum.BUY быстрей, чем operationValue.charAt(0) == 'B'.
Да и кроме состояний SELL и BUY больше никаких не предвидится, а значит его существование в общем случае вполне оправдано и изменяться он вряд ли будет.

- почему используется chatAt() ?
В общем случае charAt() показывает лучшее время, чем equals и др. способы.