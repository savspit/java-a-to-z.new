
1. Создан объект User с полями: String name, int age.

2. Создано 4 объекта User.
Каждый экземпляр класса содержит заголовок.
Каждый заголовок для большинства JVM состоит из двух машинных слов.
Размер заголовка: 32x - 8 байт, 64х - 16 байт.

2.1. Один объект User на машине 32х будет занимать:
- заголовок - 8 байт
- поле String:
		- заголовок - 8 байт
		- private int hash - 4 байта
		- private static final long serialVersionUID - 8 байт
		- private static final ObjectStreamField[] - 4 байта (ссылочная переменная на объект массива):
				- массив пустой и реализации его я не увидел, поэтому - 8 байт на заголовок массива 
		- private final char value[] - 4 байта (ссылочная переменная на объект массива):
				- заголовок - 8 байт + 2 байта (char) * 4 (длина строки "test")
- поле int - 4 байта
Итого: 8 + 8 + 4 + 8 + 4 + 8 + 4 + 8 + 2*4 + 4 = 64 байта
кратно 8-ми, поэтому выравнивания нет
Итого: 64 байта

Объектов User будет создано 4, значит общий размер: 64 * 4 = 256 байт

2.2. Один объект User на машине 64х будет занимать:
- заголовок - 16 байт
- поле String:
		- заголовок - 16 байт
		- private int hash - 4 байта
		- private static final long serialVersionUID - 8 байт
		- private static final ObjectStreamField[] - 8 байта (ссылочная переменная на объект массива):
				- массив пустой и реализации его я не увидел, поэтому - 16 байт на заголовок массива 
		- private final char value[] - 8 байта (ссылочная переменная на объект массива):
				- заголовок - 16 байт + 2 байта (char) * 4 (длина строки "test")
- поле int - 4 байта
Итого: 16 + 16 + 4 + 8 + 8 + 16 + 8 + 16 + 2*4 + 4 = 104 байта
кратно 8-ми, поэтому выравнивания нет 
Итого: 104 байта

Объектов User будет создано 4, значит общий размер: 104 * 4 = 416 байт

Выравнивание/смещение - это несколько неиспользуемых байт, 
которые размещаются после данных самого объекта. 
Это сделано для того, чтобы адрес в памяти всегда был кратным машинному слову.
Это необходимо для:
- ускорения чтения из памяти
- уменьшения количества бит для указателя на объект
- уменьшения фрагментации памяти

3. В теории не меньше одного байта. На практике ровно один байт. 
Не ноль потому, что, согласно спецификации, каждый объект должен иметь свой адрес. 
Если бы объекты были с нулевым размером, то они запросто могли бы иметь один и тот же адрес.

4. Добавлен ключ -Xmx24m - ограничение памяти Java-машины в 24 Мб

5. Поведение программы:
- выведена предварительная статистика памяти
- созданы 4 объекта User
	- объекты User помещены в очередь на финализацию (у них переопределен метод finalize())
- ссылки на объекты "обнулены"
- запущен Garbage collector. Мы как бы "предложили собрать мусор", но нет никакой гарантии, что это произойдет
Но! Т.к. мы ограничили память Java-машины - сборщик мусора очистил память
- выведена финальная статистика памяти

Что сделал сборщик мусора:
- поместил объекты User с переопределенным методом finalize() в специальный список, вызвав статический метод java.lang.ref.Finalizer.register(Object)
- объект класса Finalizer представляет собой ссылку на объект, для которого надо вызвать finalize() и хранит ссылки на следующий и предыдущий Finalizer, формируя двусвязный список
- вызов finalize() произошел в отдельном потоке "Finalizer", 
причем методы finalize() вызвались в том порядке, в котором были добавлены в список сборщиком мусора
это сделано для того, чтобы если какой-то finalize() зависнет, он не подвесил бы "Finalizer"
с другой стороны, если подвиснет какой-то finalize(), то объекты не имеющие finalize() будут удаляться,
а имеющие finalize() - будут добавляться в очередь пока не отвиснет поток "Finalizer", не завершится приложение или не кончится память