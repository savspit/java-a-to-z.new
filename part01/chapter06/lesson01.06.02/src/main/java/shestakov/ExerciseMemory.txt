
Типы сборщиков мусора:
1. Serial Collector
-XX:+UseSerialGC

2. Parallel Collector
-XX:+UseParallelGC

3. Parallel Compacting Collector
-XX:+UseParallelOldGC

4. Concurrent Mark-Sweep (CMS) Collector
-XX:+UseConcMarkSweepGC


Используемые ключи для сбора статистики:
-verbose:gc 	Включает режим логирования сборок мусора в stdout.
-Xloggc:filename 	Указывает имя файла, в который должна логироваться информация о сборках мусора. Имеет приоритет над -verbose:gc.
-XX:+PrintGCTimeStamps 	Добавляет к информации о сборках временные метки (в виде количества секунд, прошедших с начала работы программы).
-XX:+PrintGCDetails 	Включает расширенный вывод информации о сборках мусора.



-Xmx24m -Xms8m -XX:+UseSerialGC -verbose:gc -Xloggc:C:\Users\user\Documents\memory\UseSerialGC.txt -XX:+PrintGCTimeStamps -XX:+PrintGCDetails
-Xmx24m -Xms8m -XX:+UseParallelGC -verbose:gc -Xloggc:C:\Users\user\Documents\memory\UseParallelGC.txt -XX:+PrintGCTimeStamps -XX:+PrintGCDetails
-Xmx24m -Xms8m -XX:+UseParallelOldGC -verbose:gc -Xloggc:C:\Users\user\Documents\memory\UseParallelOldGC.txt -XX:+PrintGCTimeStamps -XX:+PrintGCDetails
-Xmx24m -Xms8m -XX:+UseConcMarkSweepGC -verbose:gc -Xloggc:C:\Users\user\Documents\memory\UseConcMarkSweepGC.txt -XX:+PrintGCTimeStamps -XX:+PrintGCDetails



РЕЗУЛЬТАТ АНАЛИЗА:

1. UseSerialGC

Организация Heap:
1. Новое поколение
- Eden
- Survivor 0
- Survivor 1
2. Старое поколение
- Tendured
3. PermGen
- PermGen
//////////////////////////////
PermGen - специальное пространство, существующее до Java 8.
Это место, где находились данные о метаданных объектов классов, интернационализированных строках и т.д.
Вызывало много проблем для разработчиков, т.к. было довольно трудно предсказать сколько места на все потребуется.
Результат неудачных предсказаний - java.lang.OutOfMemoryError: PermGen space.
Ну и стандартное решение таких проблем - увеличение размера PermGen.
//////////////////////////////

+ минимальное требование к ресурсам компьютера
+ т.к. всю работу выполняет последовательно в одном потоке - нет GC overhead (когда памяти осталось мало и GC постоянно работает пытаясь высвободить немного места)
- долгие паузы на сборку мусора при заметных объемах данных, т.к. в начале каждой сборки мусора работа основных потоков приложения останавливается и возобновляется только после окончания сборки.

Итог: если приложение небольшое, не чувствительно к коротким остановкам, ему доступно только одно ядро процессора: UseSerialGC - наш выбор.

2. UseParallelGC

Организация Heap:
1. Новое поколение
- Eden
- Survivor 0
- Survivor 1
2. Старое поколение
- OldGen
3. PermGen
- PermGen

- работает по тому же принципу, что и SerialGC
- небольшая фрагментация памяти, но не сильно критично, т.к. сборщиком используется относительно небольшое количество потоков
+ пауза во время остановки основных потоков приложения короче, т.к. сборкой мусора занимаются несколько потоков параллельно
+ самостоятельно подстраивается под требуемые параметры производительности

Итог: если на компьютере больше одного процессорного ядра, то лучше использовать его, а не SerialGC
Для одноядерных машин он также подходит и его также стоит использовать по-возможности.

3. UseParallelOldGC
Организация Heap:
1. Новое поколение
- Eden
- Survivor 0
- Survivor 1
2. Старое поколение
- OldGen
3. PermGen
- PermGen

+ работает по тому же принципу, что и ParallelGC, НО! отличие от него:
ParallelGC - использует мультипоточность для Нового поколения И однопоточность для Старого поколения
ParallelOldGC - использует мультипоточность для ОБОИХ (Нового и Старого) поколений, что означает,
что мы имеем более быстрый сбор мусора и более короткие остановки основных потоков приложения (Stop-the-world times)

Итог: если на компьютере больше одного процессорного ядра, то лучше использовать его, а не ParallelGC или уже тем более SerialGC.
Для одноядерных машин он также подходит и его также стоит использовать по-возможности.

4. ConcMarkSweepGC
Организация Heap:
1. Новое поколение
- Eden
- Survivor 0
- Survivor 1
2. Старое поколение
- OldGen
3. PermGen
- PermGen

+ выполняет свою работу параллельно с работой основной программы
+ минимизированность времени простоя приложения
+ режим Incremental Mode (i-cms) - временная остановка работ параллельно с основным приложением для высвобождения ресурсов процессора
- режим Incremental Mode (i-cms) - помечен как НЕ рекомендуемый к применению
- требование к ресурсам процессора и общей пропускной способности
- фрагментация OldGen (особенность работы данного сборщика мусора)
- наличие плавающего мусора, что приводит к необходимости выделять приложению (старому поколению) больше памяти, чем для других сборщиков () 20% - рекомендация Oracle
- требование к большему объему памяти

Итог: подходит приложениям, использующим большой объем долгоживущих данных

5. G1GC
Существует еще сборщик мусора G1GC, но он не является логическим продолжением линейки Serial / Parallel / CMS и не был указан в документе, поэтому о нем я ничего не написал.



ПОДВОДЯ ИТОГИ:
1. Наиболее оптимально для приложения заявок из второго модуля подойдет ParallelOldGC.
Хотя, учитывая, что в приложении вряд ли будет много пользователей, создающих/изменяющих/удаляющих заявки,
то и SerialGC ему также подойдет))
2. Для серверного приложения оптимальней будет использовать либо ParallelOldGC, либо ConcMarkSweepGC,
но какой именно - зависит от того, что за серверное приложение имеется в виду.
При больших объемах данных из предложенных сборщиков мусора лучше, скорее всего использовать ConcMarkSweepGC, может быть даже с режимом Incremental Mode.
Если в серверном приложении объем данных не велик, либо пользователей мало и нет фоновых заданий, что-то "дико" генерирующих, то может подойти и ParallelOldGC.


